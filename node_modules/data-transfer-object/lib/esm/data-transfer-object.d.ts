import { ValidationError, ValidatorOptions } from 'class-validator';
declare type NonFunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
/** Extract the data properties out of a Data Transfer Object. */
export declare type Data<T> = Pick<T, NonFunctionPropertyNames<T>>;
/** Cached validation errors from previous validation. */
declare const validationErrors: unique symbol;
/** Whether this object has already been validated. */
declare const validated: unique symbol;
/** Pending validation promise, if any. */
declare const ongoingValidation: unique symbol;
/**
 * Creates a new data transfer object which will validate and reshape its input
 * data based on the validators of its own properties. Must be extended, should
 * not be instantiated on its own.
 */
export declare abstract class DataTransferObject {
    /** Cached validation errors from previous validation. */
    private [validationErrors];
    /** Whether this object has already been validated. */
    private [validated];
    /** Pending validation promise, if any. */
    private [ongoingValidation]?;
    /**
     * Constructs a new instance of a data transfer object with the given input.
     * @param data The input data to assign to this data transfer object.
     */
    constructor(data: unknown);
    /**
     * Runs all synchronous validators on this object.
     * To run asynchronous validators as well, use `.getValidationErrorsAsync()`.
     * @param opts Options to pass to the validator system.
     */
    getValidationErrors(opts?: ValidatorOptions): ValidationError[];
    /**
     * Runs all synchronous and asynchronous validators on this object.
     * Always returns a promise. To validate synchronously, use `.getValidationErrors()`.
     * @param opts Options to pass to the validator system.
     */
    getValidationErrorsAsync(opts?: ValidatorOptions): Promise<ValidationError[]>;
    /**
     * Validates this object (sync validators only), and returns its plain data if validations pass.
     * Otherwise, throws an error or runs the appropriate handler set with `setValidationErrorHandler()`.
     *
     * To run both sync and async validators, use `.validateAsync()`.
     * @param opts Options to pass to the validator system.
     */
    validate(opts?: ValidatorOptions): Data<this>;
    /**
     * Validates this object asynchronously, and resolves to its plain data if validations pass.
     * Otherwise, rejects with an error or runs the appropriate handler set with `setValidationErrorHandler()`.
     *
     * To validate synchronously, use `.validate()`.
     * @param opts Options to pass to the validator system.
     */
    validateAsync(opts?: ValidatorOptions): Promise<Data<this>>;
    /**
     * Returns a JSON friendly object containing only data properties of this object (ie, no validation functions).
     * Automatically used by `JSON.stringify()`.
     */
    toJSON(): Data<this>;
}
export {};
